/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.axesoft.tans.client;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.hash.HashingOutputStream;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.*;
import io.netty.util.CharsetUtil;
import org.apache.commons.lang3.ArrayUtils;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

public class ClientApp {
    private static final int PAR_FACTOR = 2;

    public static final List<String> URLS = ImmutableList.of(
            "http://localhost:8081/acquire?key=billid&n=1",
            "http://localhost:8082/acquire?key=billid&n=2",
            "http://localhost:8083/acquire?key=billid&n=3");


    public static void main(String[] args) throws Exception {
        ClientApp app = new ClientApp();
        app.run();
    }
    private int n = 20000;
    private long start = 0;
    private AtomicInteger count = new AtomicInteger(0);
    private List<HttpRequest> requests;
    private List<URI> uris;

    public void run() throws Exception {

        this.uris = Lists.transform(URLS, s -> {
            try {
                return new URI(s);
            } catch (URISyntaxException e) {
                throw new RuntimeException();
            }
        });
        this.requests = Lists.transform(uris, this::createRequest);

        // Configure the client.
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            Bootstrap b = new Bootstrap();
            b.group(group)
                    .channel(NioSocketChannel.class)
                    .handler(new HttpSnoopClientInitializer());

            List<Channel> channels = new ArrayList<>();
            for (int i = 0; i < Math.min(PAR_FACTOR, uris.size()); i++) {
                // Make the connection attempt.
                URI u = uris.get(i);
                Channel ch = b.connect(u.getHost(), u.getPort()).sync().channel();
                channels.add(ch);
            }
            // Prepare the HTTP request.

            this.start = System.nanoTime();

            for (Channel ch : channels) {
                // Send the HTTP request.
                int i = count.getAndIncrement();
                ch.writeAndFlush(this.requests.get(i));
            }

            for (Channel ch : channels) {
                // Wait for the server to close the connection.
                ch.closeFuture().sync();
            }

            double millis = (System.nanoTime() - start) / 1e+6;
            double qps = n / (millis / 1000.0);
            System.out.println(String.format("POST %d in %.3f millis, QPS is %.0f", n, millis, qps));

        } finally {
            // Shut down executor threads to exit.
            group.shutdownGracefully();
        }
    }


    private HttpRequest createRequest(URI uri) {
        HttpRequest request = new DefaultFullHttpRequest(
                HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getPath() + "?" + uri.getQuery(), Unpooled.EMPTY_BUFFER);
        request.headers().set(HttpHeaderNames.HOST, uri.getHost());
        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);
        request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.TEXT_PLAIN);

        return request;
    }

    private HttpRequest selectRequest(int n) {
        int i = n % requests.size();
        HttpRequest r = requests.get(i);
        //System.out.println(r);
        return r;
    }

    public class HttpSnoopClientInitializer extends ChannelInitializer<SocketChannel> {

        @Override
        public void initChannel(SocketChannel ch) {
            ChannelPipeline p = ch.pipeline();
            p.addLast(new HttpClientCodec());
            // Remove the following line if you don't want automatic content decompression.
            p.addLast(new HttpContentDecompressor());
            // Uncomment the following line if you don't want to handle HttpContents.
            //p.addLast(new HttpObjectAggregator(1048576));
            p.addLast(new HttpSnoopClientHandler());
        }
    }

    public class HttpSnoopClientHandler extends SimpleChannelInboundHandler<HttpObject> {
        HttpResponse response;

        @Override
        public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {
            if (msg instanceof HttpResponse) {
                response = (HttpResponse) msg;
                //System.err.println("STATUS: " + response.status());
            }
            if (msg instanceof HttpContent) {
                HttpContent content = (HttpContent) msg;

                int i = count.getAndIncrement();

                if (i < 1000 || i % 1000 == 0 || n - i < 100) {
                    String s = content.content().toString(CharsetUtil.UTF_8).lines().findFirst().orElseGet(() -> "");

                    System.err.println(response.headers().get(HttpHeaderNames.HOST) + ","
                            + response.headers().get(HttpHeaderNames.FROM) +
                            "[" +  s + "]");
                }

                if (i == 100) {
                    System.err.println("...");
                }

                if (i < n) {
                    try {
                        if (i == 0) {
                            Thread.sleep((long) (Math.random() * 1));
                        }

                        ctx.writeAndFlush(selectRequest(i));
                    } catch (InterruptedException e) {
                        ctx.close();
                    }
                }
                else {
                    ctx.close();
                }
            }
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
            cause.printStackTrace();
            ctx.close();
        }
    }


}
